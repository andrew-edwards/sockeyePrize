---
title: "Bristol Bay 2025 - individual stock analysis"
author: "Andrew Edwards and Carrie Holt"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  cache = TRUE,
  cache_path = "bristol-bay-analysis-cache/",
  fig.path = "bristol-bay-analysis-figs-cache/",
  fig.width = 7,
  fig.height = 6
)

knitr::dep_prev()
```

```{r, build, echo = FALSE, eval = FALSE}
# To build either run this line or click knit button in RStudio:
rmarkdown::render("bristol-bay-analysis.Rmd")
```

```{r, packages, echo = FALSE, cache = FALSE}
load_all()
# Or:
# remotes::install_github("andrew-edwards/sockeyePrize")
# library(sockeyePrize)
library(dplyr)
library(pbsEDM)
library(pacea)    # make sure to update
library(gridExtra)
library(ggplot2)

# From Chris's hake
f <- function(x, digits = 0){

  if(is.null(x)){
    return(x)
  }

  format(round(x,
               digits),
         big.mark = ",",
         nsmall = digits)
}

```

```{r, river}
river <- "Alagnak"
```

This is for age4 and age5 for `r river`, though have do four calculations.

Try to predict:

- `age12` (my notation):  AgeClass_1.2 returns each year, say 2021 as an example. From `returns_all`.

- `age13`: `AgeClass_1.3 returns each year, (2021), an additional covariate would be AgeClass_1.2 returns.

- `age22`: AgeClass_2.2 returns each year, (2021).

- `age23`: AgeClass_2.3 returns each year, (2021), an additional covariate would be AgeClass_2.2 returns

Do each separately and then give the sum as the total prediction.

Covariates are (removing ones we don't have -- see `bristol-bay-covariates.Rmd`
for the full determination of the environmental stock-independent ones.

D PDO in year of outmigration (May-August 2019), two years prior to return, for AgeClass_1.2 and AgeClass_2.2.

D PDO in year of outmigration (May-August 2018), three years prior to return, for AgeClass_1.3 and AgeClass_2.3.

D from "total_np_salmon.csv", total pink salmon abundance in N Pacific returning the same return year as being predicted (2021), to predict AgeClass_1.2 and AgeClass_2.2 returns

D total pink salmon abundance in N Pacific returning the year prior to the year being predicted (2020), to predict AgeClass_1.3 and AgeClass_2.3 returns (an alternative hypothesis is that pink salmon in the same return year as being predicted could be used for these age classes as well)

```{r, cov}
bristol_bay_covariates
```

# Returns

Not doing combined age4 then age5 like for Fraser River, rather doing each of
the four listed above. Think can just make one big tibble with everything, and
then select the response variable appropriately.


Won't need:
```{r classes}
classes <- c("AgeClass_1.2",
             "AgeClass_1.3",
             "AgeClass_2.2",
             "AgeClass_2.3")
```

(We did include more for Fraser River).

```{r returns}
river_returns <- dplyr::filter(returns_all,
                               River == river)
river_returns
summary(river_returns)

river_returns_2 <- dplyr::select(river_returns,
                               ReturnYear,
                               Total_Returns,
                               unlist(classes)) %>%
  rowwise() %>%
  mutate(total_of_included = sum(c_across(any_of(classes)),
                                 na.rm = TRUE)) %>%
  mutate(total_difference = Total_Returns - total_of_included) %>% ungroup()
      # to check what we're missing by excluding some classes

river_returns_2
summary(river_returns_2)
summary(river_returns_2$total_of_included)
summary(river_returns_2$total_difference)
select(river_returns_2, ReturnYear, total_difference)
```
So max excluded is about 10% of the maximum total (might not be the same year),
which is probably fine.

```{r rename}
input_returns <- select(river_returns,
                        year = ReturnYear,
                        age12 = AgeClass_1.2,
                        age13 = AgeClass_1.3,
                        age22 = AgeClass_2.2,
                        age23 = AgeClass_2.3)
summary(input_returns)

input_returns %>% pacea::a()
```

No actual 0's, but some `10^-8` in there. No need to replace any leading zeros
like for Fraser River.

```{r, back}
# Now add five earlier years with NA's, since things like PDO and spawners might
#  go back 4-5 years.
yr <- min(input_returns$year)
yr
input_returns <- rbind(c(yr - 5, rep(NA, 4)),
                     c(yr - 4, rep(NA, 4)),
                     c(yr - 3, rep(NA, 4)),
                     c(yr - 2, rep(NA, 4)),
                     c(yr - 1, rep(NA, 4)),
                     input_returns)
input_returns
input_returns %>% tail()

# For Bristol Bay, based on first stock analysing
if(min(input_returns$year != 1958)){
  stop("check covariates and years")
}

```

HERE

```{r, exit3, cache = FALSE, eval = FALSE}
knitr::knit_exit()
```

Now join returns and System-wide covariates into one tibble.

```{r input}
input_river <- left_join(input_returns,
                         one_spawners_use)

input_river <- left_join(input_river,
                         fraser_covariates)
input_river %>% head(10) %>% a()
input_river %>% tail() %>% a()
```


```{r, indices}
summary(input_river)

T <- nrow(input_river)   # T as in index T is final year of data, can include
                        # NA's at start. Not used in calculations, just plotting
                        # and printing results.

T    # do double check that manually, esp for age5 and other rivers

age4_first_year_index <- min(which(!is.na(input_river$age4))) # generalise for age4
#and age5 if needed
age4_first_year_index

age4_first_year <- input_river$year[age4_first_year_index]
age4_first_year
```

# EDM with covariates

Do a big plot of everything:
```{r plotcovariates, fig.height = 9}
to_plot <- tidyr::pivot_longer(input_river,
                               cols = -year) %>%
  mutate(name = factor(name))

p <- ggplot(to_plot,
            aes(year, value)) +
  geom_path() +                        # leaves gaps for NA's, but none now
  # facet_wrap(~name, scales = "free_y")
  facet_grid(name ~ ., scales = "free_y")

p

# It reorders them alphabetically; need something like this:
#  mutate(name = factor(name, levels = paste0("X", 1:12))) %>%
```

Not worrying about span idea for now, can select the relevant covariates as lags
in EDM (i.e. just exclude ones that don't have full span).

```{r corrplot}
# pairs(input_river,
#      lower.panel = panel.cor)
GGally::ggpairs(input_river)
```

Useful, but of course doesn't highlight correlation of lags.
```{r corrplot22, fig.width = 9}
corrplot::corrplot(cor(input_river,
                       use = "pairwise.complete.obs"),
  method = "number",
  type = "upper" # show only upper side
  )
```

Update these manually, using 0.3 to exclude related covariates.

For Late Stuart, the coefficients from `pdo_winter_mean` downwards are the same
as for Chilko, as expected because they are the non-stock specific covariates.

For Raft, non-stock specific covariates:

- `total_spawners` and `effective_spawners` (as expected), go with effective (Catarina).

- Chilko: `total_spawners` or `effective_spawners` with either `pink` or `total`; though
  could always try (0.3 cut off is a bit arbitrary). I think we should stick
  with `effective_spawners` and `pink` though. Late Stuart,  Quesnel, and Raft: not correlated now
  (so bit more justified in sticking with them). Very cyclic compared to Chilko
  (Raft maybe not so much, haven't looked to carefully.).

So, as for all previous stocks, remove:

- `fraser_peak_spring`

- `total`

- `total_spawners`

Given BI was not in the best runs for either age4 or age5 for Chilko, not going
to bother with it going forward (and correlated with PDO anyway).

```{r, exit1, cache = FALSE, eval = FALSE}
knitr::knit_exit()
```

# MVE analysis

Not doing an 'everything as baseline' run either, since takes a while. And just
including PDO (pdo might still appear in some variable names, as for Chilko we
tried PDO and BI separately).

## Remove correlated covariates

As noted above, removing three correlated covariates, plus BI since not going to
sue now.

```{r, reduced}
input_river_reduced <- select(input_river,
                              -c("fraser_peak_spring",
                                 "total",
                                 "total_spawners",
                                 "bi_anomaly"))
```

## Age 4

First, lags with PDO (not BI). Do not eval this chunk after doing it once if it
takes a while and previous chunks have changed.

```{r, red1}
lags_reduced_pdo <- list(age4 = c(1, 2, 3, 4),
                         effective_spawners = c(4),
                         pdo_winter_mean = c(1, 2),
                         fraser_mean_spring = c(1, 2),
                         pink = c(1, 2),
                         sst_spring = c(1, 2),
                         zoo_total_biomass = c(1, 2))

tictoc::tic()
mve_reduced_pdo <- multiview_embedding(data = input_river_reduced,
                                       response = "age4",
                                       lags = lags_reduced_pdo)
# Centre and scaling and first differencing get done automatically, in
#  state_space_reconstruction_for_sve()
tictoc::toc()

saveRDS(mve_reduced_pdo, file = "mve_reduced_pdo.rds")
```

Reload and then see results.

```{r, red1load}
mve_reduced_pdo <- readRDS("mve_reduced_pdo.rds")

mve_reduced_pdo$rho_prediction_from_mve
mve_reduced_pdo$rho_each_top_subset

# So there's lots, so need to just show a few of these:
mve_reduced_pdo$lags_of_top_subsets[1:20]

# Look at the top few predictions:

mve_reduced_pdo[["response_each_subset"]][mve_reduced_pdo$top_subsets_for_rho_index[1:5]]

mve_reduced_pdo$response_predicted_from_mve   # Overall mve prediction, including for T+1.
```

```{r red1fig}
plot(input_river$age4,
     mve_reduced_pdo$response_predicted_from_mve[-(T+1)],
     xlab = "Age4 returns - observed",
     ylab = "Age4 returns - predicted")

legend("topleft", legend = c(paste("rho is",
                                    round(mve_reduced_pdo$rho_prediction_from_mve, 2)),
                              paste("prediction is",
                                    f(mve_reduced_pdo$response_predicted_from_mve[T+1]))))
abline(a = 0, b = 1)
abline(h = mve_reduced_pdo$response_predicted_from_mve[T+1], col = "red")
```

```{r, exit2, cache = FALSE, eval = FALSE}
knitr::knit_exit()
```

## Age 5

Remove lags that weren't important for age4 (see Chilko for more explanation),
else age5 will take about 6 hours to run.

So looking at lags from the top 20 sets from age4 results above. Manually copy the code that defined them, then remove
ones that show up in top 20 sets, to leave ones not in top 20. Easiest to copy
`mve_reduced_pdo$lags_of_top_subsets[1:20]` into R to scroll through and search.

First set of age4 lags.
```{r, lagscheck}
lags_reduced_pdo

lags_reduced_pdo_not_in_top_20 <- list()   # none!
```

Chilko had `fraser_mean_spring` lag 1, Late Stuart did not (so took twice as
long to run the age5 calculation). Raft has everything in the top 20, including
zooplankton for the first time (for any stock so far), and it was in the top 2 models!

So keep everything I guess.

So results in 21 lags below, which is about 8 hours. Oh well, just set it running.

Do not eval this chunk after doing it once if it
takes a while and previous chunks have changed.

```{r, red3}
lags_reduced_pdo_age5 <- list(age4 = c(1),
                              age5 = c(1, 2, 3, 4, 5),
                              effective_spawners = c(5),
                              pdo_winter_mean = c(1, 2, 3),
                              fraser_mean_spring = c(1, 2, 3),
                              pink = c(1, 2, 3),
                              sst_spring = c(1, 2, 3),
                              zoo_total_biomass = c(1, 2, 3))
tictoc::tic()
mve_reduced_pdo_age5 <- multiview_embedding(data = input_river_reduced,
                                            response = "age5",
                                            lags = lags_reduced_pdo_age5)
# Centre and scaling and first differencing get done automatically, in
#  state_space_reconstruction_for_sve()
tictoc::toc()

saveRDS(mve_reduced_pdo_age5, file = "mve_reduced_pdo_age5.rds")
```

Reload and then see results.

```{r, red3load}
mve_reduced_pdo_age5 <- readRDS("mve_reduced_pdo_age5.rds")

mve_reduced_pdo_age5$rho_prediction_from_mve
mve_reduced_pdo_age5$rho_each_top_subset

# So there's lots, so need to just show a few of these:
mve_reduced_pdo_age5$lags_of_top_subsets[1:20]

# Look at the top few predictions:

mve_reduced_pdo_age5[["response_each_subset"]][mve_reduced_pdo_age5$top_subsets_for_rho_index[1:5]]

mve_reduced_pdo_age5$response_predicted_from_mve   # Overall mve prediction, including for T+1.
```

```{r red3fig}
plot(input_river$age5,
     mve_reduced_pdo_age5$response_predicted_from_mve[-(T+1)],
     xlab = "Age5 returns - observed",
     ylab = "Age5 returns - predicted")

legend("topleft", legend = c(paste("rho is",
                                    round(mve_reduced_pdo_age5$rho_prediction_from_mve, 2)),
                              paste("prediction is",
                                    f(mve_reduced_pdo_age5$response_predicted_from_mve[T+1]))))
abline(a = 0, b = 1)
abline(h = mve_reduced_pdo_age5$response_predicted_from_mve[T+1], col = "red")
```

## Summarise results

Summarise results of the two runs, and add them together (no need for picking
best like Chilko, as we haven't done a BI run here).

```{r, summarylim}
lim_common_max <- max(c(input_river$age4,
                        mve_reduced_pdo$response_predicted_from_mve,
                        input_river$age5,
                        mve_reduced_pdo_age5$response_predicted_from_mve),
                      na.rm = TRUE)
lim_common_max
lim_common = c(0, lim_common_max)
```

Panel plot, now adding in time series plots also. Left column plots have same
axes for age4 and age5, not so in right-hand time series.
```{r, summaryplot}
par(mfrow = c(2,2))

# Age4 correlation
plot(input_river$age4,
     mve_reduced_pdo$response_predicted_from_mve[-(T+1)],
     xlab = "Age4 returns - observed",
     ylab = "Age4 returns - predicted",
     main = "Age4",
     xlim = lim_common,
     ylim = lim_common)

legend("topleft", legend = c(paste("rho is",
                                   round(mve_reduced_pdo$rho_prediction_from_mve, 2)),
                              paste("prediction is",
                                    f(mve_reduced_pdo$response_predicted_from_mve[T+1]))))
abline(a = 0, b = 1)
abline(h = mve_reduced_pdo$response_predicted_from_mve[T+1], col = "red")

# Age4 time series
plot(input_river$year,
     input_river$age4,
     type = "o",
     main = "Age4",
     xlab = "Year",
     ylab = "Age4 returns")
     # ylim = lim_common)

points(c(input_river$year, max(input_river$year) + 1),
       mve_reduced_pdo$response_predicted_from_mve,
       pch = 16,
       col = "red",
       cex = 0.8)

legend("topleft",
       legend = c("observed", "predicted"),
       pch = c(1, 16),
       col = c("black", "red"))

# Age5 correlation
plot(input_river$age5,
     mve_reduced_pdo_age5$response_predicted_from_mve[-(T+1)],
     xlab = "Age5 returns - observed",
     ylab = "Age5 returns - predicted",
     main = "PDO age5",
     xlim = lim_common,
     ylim = lim_common)

legend("topleft", legend = c(paste("rho is",
                                   round(mve_reduced_pdo_age5$rho_prediction_from_mve, 2)),
                              paste("prediction is",
                                    f(mve_reduced_pdo_age5$response_predicted_from_mve[T+1]))))
abline(a = 0, b = 1)
abline(h = mve_reduced_pdo_age5$response_predicted_from_mve[T+1], col = "red")

# Age5 time series
plot(input_river$year,
     input_river$age5,
     type = "o",
     main = "Age5",
     xlab = "Year",
     ylab = "Age5 returns")
     # ylim = lim_common)

points(c(input_river$year, max(input_river$year) + 1),
       mve_reduced_pdo_age5$response_predicted_from_mve,
       pch = 16,
       col = "red",
       cex = 0.8)

legend("topleft",
       legend = c("observed", "predicted"),
       pch = c(1, 16),
       col = c("black", "red"))
```

Summarise, and then sum together age4 and age5 to get our prediction.

```{r, summarise}
summary <- tibble(age = "age4",
                  run = "PDO",
                  rho = mve_reduced_pdo$rho_prediction_from_mve ,
                  prediction = mve_reduced_pdo$response_predicted_from_mve[T+1])
summary <- rbind(summary,
                 c("age5",
                   "PDO",
                   mve_reduced_pdo_age5$rho_prediction_from_mve,
                   mve_reduced_pdo_age5$response_predicted_from_mve[T+1])) %>%
  dplyr::mutate_at(vars(age,
                        run),
                   factor) %>%
  dplyr::mutate_at(vars(rho,
                        prediction),
                   as.numeric)

summary

knitr::kable(summary,
             digits = c(NA, NA, 2, 6))
stopifnot(nrow(summary) == 2)

total_returns_prediction <- sum(summary$prediction)
```

The prediction for combined age4 and age5 returns `r river` is ... `r f(total_returns_prediction)`.
