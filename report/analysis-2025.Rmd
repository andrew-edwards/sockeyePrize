---
title: "Analysing data for 2025 competition"
author: "Andrew Edwards and Carrie Holt"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  cache = TRUE,
  cache_path = "analysis-2025-cache/",
  fig.path = "analysis-2025-figs-cache/",
  fig.width = 7,
  fig.height = 6
)
  # comment = "#>",
```

```{r, build, echo = FALSE, eval = FALSE}
# To build either run this line or click knit button in RStudio:
rmarkdown::render("analysis-2025.Rmd")
```

```{r, packages, echo = FALSE, cache = FALSE}
load_all()
# Or:
# remotes::install_github("andrew-edwards/sockeyePrize")
# library(sockeyePrize)
library(dplyr)
library(pbsEDM)
library(pacea)    # make sure to update
library(gridExtra)
```

# Data

Data are saved within the current package, as supplied by organisers (see
data-raw/data-2025.Rmd for details):

1.	All 14 runs across the three systems
a.	Brood table
b.	Return table
c.	First year at sea table

```{r data}
brood_all
returns_all
at_sea_all
```

# Understanding data, just Chilko

## Brood data

Just look at brood data first:
```{r understand}
summary(brood_all)

summary(dplyr::filter(brood_all, System == "Fraser River"))
```

Shows there are five funs for Fraser River. Let's just focus on one:

```{r onerun}
one_brood <- dplyr::filter(brood_all, River == "Chilko")

sum(one_brood[1, 5:22], na.rm = TRUE)
one_brood$Total_Recruits[1]

sum(one_brood[7, 5:22], na.rm = TRUE)
one_brood$Total_Recruits[7]
```
`Total_Recruits` seems to be sum of other columns.

If spawned in Sept/Oct 2013 (BroodYear), go to sea summer 2014. Then
`AgeClass_0.3` is spawners that spent 0 winters (ignore them being eggs) in
freshwater and three winters in ocean. So they come back to freshwater in 2017,
as age 4. Add together the numbers and add 1 to get the age. Recruits looks to
be the sum of the ageClass columns.

Brood data (this might not be needed):

```{r sum}
classes_age4 <- c("AgeClass_0.3",
                  "AgeClass_1.2",
                  "AgeClass_2.1")

classes_age5 <- c("AgeClass_0.4",
                  "AgeClass_1.3",
                  "AgeClass_2.2",
                  "AgeClass_3.1")

one_brood_age45 <- rowwise(one_brood) %>%
  mutate(age4 = sum(c_across(any_of(classes_age4)),
                    na.rm = TRUE)) %>%
  mutate(age5 = sum(c_across(any_of(classes_age5)),
                    na.rm = TRUE)) %>%
  ungroup() %>%
  select("System",
         "River",
         "BroodYear",
         "age4",
         "age5")

one_brood_age45 %>% pacea::a()
# Bristol Bay would have four age classes
```

## Returns

We want to predict `returns_all$Total_Returns`, by doing age4 and age5
separately and then sum.

```{r sumreturns}
one_returns <- dplyr::filter(returns_all, River == "Chilko")

classes_age4 <- c("AgeClass_0.3",
                  "AgeClass_1.2",
                  "AgeClass_2.1")

classes_age5 <- c("AgeClass_0.4",
                  "AgeClass_1.3",
                  "AgeClass_2.2",
                  "AgeClass_3.1")

one_returns_age45 <- rowwise(one_returns) %>%
  mutate(age4 = sum(c_across(any_of(classes_age4)),
                    na.rm = TRUE)) %>%
  mutate(age5 = sum(c_across(any_of(classes_age5)),
                    na.rm = TRUE)) %>%
  ungroup() %>%
  select("System",
         "River",
         "ReturnYear",
         "age4",
         "age5")

one_returns_age45 %>% a()
```



## At Sea

`Juveniles_Marine_Entry` is sum of other columns.

Bristol Bay: all separate 1.2, 1.3, 2.2 and 2.3. Based on what they recommend.



# Fraser River

What we would put into pbsEDM.

Try to predict:

- age4 returns each year, say 2021 as an example. From `one_returns_age45`.

- age5 returns each year (2021), an additional covariate would be age4 returns.

Do each seperately and then give the sum as the total prediction.

So, age4 returns in 2021:

 2017: spawned in freshwater as age0, though think it's the winter, so could be
 early 2018
 2018: stay in freshwater as age1
 2019: outmigration to ocean as age2
 2020: at-sea as age3
 2021: return as age4

Covariates would be (D = Done, or not needed):

D Not needed: at-sea total abundances two years prior (2019) to the return year for age4
  [think this was when we thought at-sea was juveniles; likely not needed now]

D Not needed: at-sea total abundances average of two years ago and three years (2018 and 2019) ago prior to
  the return year for age5 for Chilko, for others just do three years ago
  (2018). [ditto]

D PDO in the winter (Nov 2018 to Mar 2019) preceding outmigration for age4.

- PDO in the winter (average of Nov 2017 to Mar 2018 and Nov 2018 to Mar 2019)
  preceding outmigration for age5 for Chilko.

- PDO in the winter (Nov 2017 to Mar 2018) preceding outmigration for other
  age5's.

- Temperature from buoys: "West Sea Otter" (Apr-Jul average), "East Dellwood
  Knolls" (Apr-Jul average), "Halibut Bank" (Apr-Jun average). Year of
  outmigration, after the PDO Mar calculation, so 2019 for 2021 return year.

- peak (max daily value) and average daily Fraser River Discharge from Apr-Jun
  (same as buoy temperatures). Try Chris's code.

- total pink salmon abundance in N Pacific. Second or third years of marine
  life of the sockeye (as competition). Year after the temperature data (second
  year), 2020.
  W: Carrie contacting Hannah Hunter. `np_salmon` has
  `return_year_of_np_salmon`.


- total salmon abundance in N Pacific. Same as pink. Andy: though won't the
  non-pinks be out there for longer so we should look at multiple years?

- copepods the year of outmigration (same as SST). Total biomass anomaly.

- bifurcation index, year of outmigration (same as SST).

# Bristol Bay

What we would put into pbsEDM.

Try to predict:

- AgeClass_1.2 returns each year, say 2021 as an example. From `returns_all`.

- AgeClass_1.3 returns each year, (2021), an additional covariate would be AgeClass_1.1 returns.

- AgeClass_2.2 returns each year, (2021).

- AgeClass_2.3 returns each year, (2021), an additional covariate would be AgeClass_2.2 returns

Do each separately and then give the sum as the total prediction.

Covariates would be:

- at-sea total abundances in year of outmigration (2019), two years prior to return, for AgeClass_1.2 and AgeClass_2.2.

- at-sea total abundances in year of outmigration (2018), three year prior to the return year for AgeClass_1.3 and AgeClass_2.3.

- PDO in year of outmigration (May-August 2019), two years prior to return, for AgeClass_1.2 and AgeClass_2.2.

- PDO in year of outmigration (May-August 2018), three years prior to return, for AgeClass_1.3 and AgeClass_2.3.

- from "total_np_salmon.csv", total pink salmon abundance in N Pacific returning the same return year as being predicted (2021), to predict AgeClass_1.2 and AgeClass_2.2 returns

- total pink salmon abundance in N Pacific returning the year prior to the year being predicted (2020), to predict AgeClass_1.3 and AgeClass_2.3 returns (an alternative hypothesis is that pink salmon in the same return year as being predicted could be used for these age classes as well)

- from "total_np_salmon.csv", total salmon abundance in N Pacific returning the same return year as being predicted (2021), to predict AgeClass_1.2 and AgeClass_2.2 returns

- total salmon abundance in N Pacific returning the year prior to the year being predicted (2020), to predict AgeClass_1.3 and AgeClass_2.3 returns (an alternative hypothesis is that salmon in the same return year as being predicted could be used for these age classes as well)

- additional covariates for which we currently do not have data:

- Median Bristol Bay Sea Level Pressure between May–August in year cohort entered ocean (source: ERDDAP ICOADS)

- Median Bristol Bay SST between May–August in year cohort entered ocean (source: ERDDAP HadISST)

- Median Bristol Bay wind stress between May–August in year cohort entered ocean (source: ERDDAP ICOADS)



# Columbia River

What we would put into pbsEDM.

Try to predict:

- AgeClass_1.1 returns each year, say 2021 as an example. From `returns_all`.

- AgeClass_1.2 returns each year, (2021), an additional covariate would be AgeClass_1.1 returns.

- AgeClass_1.3 returns each year, (2021), an additional covariate would be AgeClass_1.2 returns.

- AgeClass_2.2 returns each year, (2021)

Do each separately and then give the sum as the total prediction.

Covariates would be:

- at-sea total abundances in year of outmigration (2020), one year prior to return, for AgeClass_1.1.

- at-sea total abundances in year of outmigration (2019), two years prior to the return year for AgeClass_1.2 and AgeClass_2.2.

- at-sea total abundances in year of outmigration (2018), three years prior to the return year for AgeClass_1.3.

- PDO in the year prior to outmigration (Nov 2019-March 2020) for returning AgeClass_1.1.

- PDO in the year prior to outmigration (Nov 2018-March 2019) for returning AgeClass_1.2 and AgeClass_2.2.

- PDO in the year prior to outmigration (Nov 2017-March 2018) for returning AgeClass_1.3.

- As for Fraser River, temperature from buoys: "Halibut Bank" (Apr-Jun average),
  "West Sea Otter" (Apr-Jul average), "East Dellwood Knolls" (Apr-Jul average),
  Year of outmigration, after the PDO Mar calculation.

- from "total_np_salmon.csv", total pink salmon abundance in N Pacific returning the same return year as being predicted (2021), to predict AgeClass 1.1, AgeClass_1.2 and AgeClass_2.2 returns (noting pink salmon might not compete with AgeClass_1.1)

- total pink salmon abundance in N Pacific returning the year prior to the year being predicted (2020), to predict AgeClass_1.3 returns (an alternative hypothesis is that pink salmon in the same return year as being predicted could be used for this age class as well)

- from "total_np_salmon.csv", total salmon abundance in N Pacific returning the same return year as being predicted (2021), to predict AgeClass_1.1, AgeClass_1.2 and AgeClass_2.2 returns

- total salmon abundance in N Pacific returning the year prior to the year being predicted (2020), to predict AgeClass_1.3  returns (an alternative hypothesis is that salmon in the same return year as being predicted could be used for this age class as well)

- copepods the year of outmigration (same as SST). Total biomass anomaly.

- bifurcation index, year of outmigration.

# Analysis for Fraser River Chilko

Gradually construct `input_age4` tibble to go into pbsEDM, based on ideas above. `return_year` is the year that
the age4's return to freshwater, and other variables will be time-shifted such
that we expect the influence to correspond to `return_year`; i.e. 2021
represents the influence on returns in 2021, but the PDO column represent PDO from a few
years earlier.

## Age4 returns

```{r inputage4}
river <- "Chilko"

input_age4 <- select(one_returns_age45,      # only for Chilko
                     return_year = ReturnYear,
                     age4) %>%
  filter(return_year != 1951)       # since age4 is 0 for 1951.
input_age4 <- rbind(input_age4,
                    c(max(input_age4$return_year) + 1, NA))  # Add forecast year
input_age4
input_age4 %>% tail()

prediction_year_index <- nrow(input_age4)
prediction_year_index
expect_equal(pull(input_age4[prediction_year_index, "return_year"] ),
             2025)
```

## At sea abundances (not needed now)

Think we don't need. Turns out (via Gottfried) these are just return numbers
lined up by ocean entry year. So values are included elsewhere (though he
couldn't get Bristol Bay to match up). He's also working out some 0 v NA
issues.

Keeping code here but not running or showing it, as don't need `at_sea_abundance`.

```{r inputage4a, eval = FALSE, echo = FALSE}
at_sea <- filter(at_sea_all,
                 River == river) %>%
  select(marine_entry_year = MarineEntryYear,
         at_sea_abundance = Juveniles_Marine_Entry) %>%
  mutate(return_year = marine_entry_year + 2)

at_sea
at_sea %>% tail()    # This has 2025 return_year, which we need.

# at_sea$at_sea_abundance     # visually check that only early and end ones
                              # are 0, for next line. Think can do at end, as
                              # left_join will take care of some.

# at_sea <- filter(at_sea_abundance,
#                           total_abundance > 0)

input_age4 <- left_join(input_age4, at_sea) %>%
  select(-"marine_entry_year")

input_age4
input_age4 %>% tail()
```

### PDO in winter.

PDO in the winter (Nov 2018 to Mar 2019) preceding outmigration for age4.

Bit fiddly to group Nov to Mar, doing a quick kludge here but
should generalise in a function and add some checks. TODO at some point.

```{r pdo}
winter_months <- c(1, 2, 3, 11, 12)
pdo_winter_months <- filter(pdo, month %in% winter_months)
pdo_winter_months <- pdo_winter_months[-(1:3), ]    # need to generalise
pdo_winter_months <- cbind(pdo_winter_months,
                           winter_group = rep(1:(length(unique(pdo_winter_months$year)) - 1),
                                              each = length(winter_months))) %>%
  as_tibble()
pdo_winter_months

pdo_winter <- summarise(group_by(pdo_winter_months,
                                 winter_group),
                        return_year = max(year) + 2,     # fish returning 2
                                        # years later
                        pdo_winter_mean = mean(anomaly)) %>%
  select(-c("winter_group"))

pdo_winter %>% tail()

input_age4 <- left_join(input_age4, pdo_winter)

input_age4
input_age4 %>% tail()
```

### Buoy temperatures

- Temperature from buoys: "Halibut Bank" (Apr-Jun average), "West Sea Otter" (Apr-Jul average), "East Dellwood Knolls" (Apr-Jul average). Year of
 outmigration, after the PDO Mar calculation.

Adapting from the pacea buoys vignette:

```{r buoys}
buoy_names <- c("Halibut Bank",
                "West Sea Otter",
                "East Dellwood Knolls") # This is their order in the data it seems

buoys <- filter(buoy_metadata,
                name %in% buoy_names)
buoys   # shows we have SST for quite different depths

buoy_temps <- filter(buoy_sst,
                     stn_id %in% buoys$stn_id)

buoy_ranges <- buoy_temps %>%
  group_by(stn_id) %>%
  summarise(start = min(date),
            end = max(date))
buoy_ranges   # looks good
```

### Buoy 1

Do each buoy separately, since slightly different time spans, and need to
manually check data.
```{r buoys1}
i_buoy <- 1
id <- buoy_ranges$stn_id[i_buoy]
id
filter(buoy_metadata, stn_id == id)$name

buoy_sst_1 <- filter(buoy_sst,
                     stn_id == id,
                     lubridate::month(date) %in% c(4, 5, 6))  # Apr-Jun

plot(buoy_sst_1,
     stn_id = id)
```

That figure doesn't show any obvious outliers that need looking into.

```{r buoys1a}
plot(buoy_sst_1$date,
     buoy_sst_1$sst)
```
That does show 2023 looks a bit odd, maybe short on data:
```{r buoys1b}
plot(buoy_sst_1,
     stn_id = id,
     year_highlight = 2023)
```
As suggested, not a complete time series so need to exclude.

Look more systematically, first removing the rows with NA's.

```{r buoys1c}
buoy_sst_1 <- filter(buoy_sst_1,
                     !is.na(sst))

buoy_sst_1_mean <- summarise(group_by(buoy_sst_1,
                                      year = lubridate::year(date)),
                             num_days = n(),
                             sst_average = mean(sst))
buoy_sst_1_mean %>% a()
sort(buoy_sst_1_mean$num_days)
```
So there should be maximum of 91 days of SST from Apr-Jun. Need to check if
missing values are random or systematic.

```{r buoys1d}
buoy_sst_1_mean %>% a()
sort(buoy_sst_1_mean$num_days)
```

Agh, 2023 is the year we will need, and that's problematic for this buoy. So
maybe look for another nearby buoy. Could look how well correlated this one is
to other close ones. TODO.

But first try the second of our originally planned buoys.

### Buoy 2

Do each buoy separately, since slightly different time spans, and need to
manually check data.
```{r buoys2}
i_buoy <- 2
id <- buoy_ranges$stn_id[i_buoy]
id
filter(buoy_metadata, stn_id == id)$name

buoy_sst_2 <- filter(buoy_sst,
                     stn_id == id,
                     lubridate::month(date) %in% c(4, 5, 6, 7))  # Apr-Jul

plot(buoy_sst_2,
     stn_id = id)
```

That figure doesn't show any obvious outliers that need looking into, except
maybe that one in the middle. TODO see if the following highlights it.

```{r buoys2a}
plot(buoy_sst_2$date,
     buoy_sst_2$sst)
```
That does show 2013 missing, 1994 short on data probably:
```{r buoys2b}
plot(buoy_sst_2,
     stn_id = id,
     year_highlight = 1994)
```
As suggested, not a complete time series so need to exclude.

Look more systematically, first removing the rows with NA's for this, but need
to keep them in for the plotting.

```{r buoys2c}
buoy_sst_2_mean <- summarise(group_by(filter(buoy_sst_2,
                                             !is.na(sst)),
                                      year = lubridate::year(date)),
                             num_days = n(),
                             sst_average = mean(sst))
buoy_sst_2_mean %>% a()
sort(buoy_sst_2_mean$num_days)
```
So there should be maximum of 122 days of SST from Apr-Jun. Need to check if
missing values are random or systematic.

```{r buoys2d}
buoy_sst_2_mean %>% a()
sort(buoy_sst_2_mean$num_days)

plot(buoy_sst_2_mean$year,
     buoy_sst_2_mean$sst_average,
     type = "o",
     main = "Before removing low counts")
```

Think just have to look at potentially problematic years in turn. Making plots
in groups of 8 years, then after list the ones to keep/exclude.

```{r buoys2e}
# par(mfrow = c(8, 4))   # Don't need to do 2025
buoy_sst_2_plots <- list()
for(i_year in 1:32){
  year_val <- buoy_sst_2_mean$year[i_year]
  # buoy_sst_2_plot_names[[i_year]] <- paste0("buoy_sst_2_plot_",
  #                                        year_val)
  #assign(paste0("buoy_sst_2_plot_",
  #              year_val),
  buoy_sst_2_plots[[i_year]] <-
    plot(buoy_sst_2,
         stn_id = id,
         years = year_val,
         year_highlight = NA, #year_val,
         title = year_val)
  # %>% ggplot2::ggplotGrob()
}

plt <- cowplot::plot_grid(plotlist = buoy_sst_2_plots[1:8],
                   ncol = 2,
                   nrow = 4)
```

```{r buoys2ebigplot, fig.width = 8, fig.height = 10}
plt
# If want to add global axis labels:
#y_grob <- textGrob("Depth (m)",
#                     gp = gpar(fontsize = label_size),
#                     rot = 90)
#  x_grob <- textGrob("Year",
#                     gp = gpar(fontsize = label_size),
#                     vjust = -0.5)
# grid.arrange(arrangeGrob(plt)) # , left = y_grob, bottom = x_grob))
```

```{r buoys2ebigplot2, fig.width = 8, fig.height = 10}
cowplot::plot_grid(plotlist = buoy_sst_2_plots[9:16],
                   ncol = 2,
                   nrow = 4)
```

```{r buoys2ebigplot3, fig.width = 8, fig.height = 10}
cowplot::plot_grid(plotlist = buoy_sst_2_plots[17:24],
                   ncol = 2,
                   nrow = 4)
```

```{r buoys2ebigplot4, fig.width = 8, fig.height = 10}
cowplot::plot_grid(plotlist = buoy_sst_2_plots[25:32],
                   ncol = 2,
                   nrow = 4)
```

Now document the years to keep for this buoy. Just visually look at figures and
keep those without any 'large gaps' in one
area; or rather, small gaps are okay if they are spread out. Quick for now, a
little subjective, can make more explicitly later if needed.
```{r buoys2keep}
buoy_sst_2_years_to_keep <- c(1991,
                              1996,
                              1999,
                              2000,
                              2002:2018,
                              2020:2021,
                              2023)

buoy_sst_2_mean_keep <- filter(buoy_sst_2_mean,
                               year %in% buoy_sst_2_years_to_keep)
buoy_sst_2_mean_not_keep <- filter(buoy_sst_2_mean,
                                   !(year %in% buoy_sst_2_years_to_keep))

# Keeping these:
buoy_sst_2_mean_keep %>% a()

# Not keeping these:
buoy_sst_2_mean_not_keep %>% a()

plot(buoy_sst_2_mean$year,
     buoy_sst_2_mean$sst_average,
     type = "o",
     main = "Black - all; red - years keeping")

points(buoy_sst_2_mean_keep$year,
       buoy_sst_2_mean_keep$sst_average,
       type = "o",
       col = "red")
```
Shows that you can't simply just have a cut off based on `num_days`.

To add to the EDM input file:
```{r buoy2keep}
buoy_sst_2_mean_keep

buoy_sst_2_mean_input <-
  rename(buoy_sst_2_mean_keep,
         buoy_sst_2 = sst_average) %>%
  mutate(return_year = year + 2)

buoy_sst_2_mean_input
tail(buoy_sst_2_mean_input)

input_age4 <- left_join(input_age4,
                        select(buoy_sst_2_mean_input,
                               c("return_year", "buoy_sst_2")))

input_age4
input_age4 %>% tail()
```


\clearpage

### Fraser River Discharge

- peak (max daily value) and average daily Fraser River Discharge from Apr-Jun
  (same as buoy temperatures). Try Chris's code.

### Total Pink Salmon abundance in North Pacific

- total pink salmon abundance in N Pacific. Second or third years of marine
  life of the sockeye (as competition). Year after the temperature data (second
  year), so 2020 (for age4 returning in 2021).

  So the Pinks that are in the
  ocean in 2020.
  `np_salmon` has `return_year_of_np_salmon`. So we would want the
  `return_year_of_np_salmon` to be 2021, as those will be in the ocean in 2020.
  BUT, that implies `return_year = 2025` sockeye (what we want to predict), we will need the
  pinks at sea that are also returning in 2025, which we won't have.
  [Carrie contacting Hannah Hunter also].

The Pink Salmon only spend one year at sea. Think we want the Pink Salmon that return in

```{r npsalmon}
tail(np_salmon)
```

### Total salmon abundance in N Pacific

- total salmon abundance in N Pacific. Same as pink. Andy: though won't the
  non-pinks be out there for longer so we should look at multiple years?

### Copepods the year of outmigration

Total biomass anomaly in SoG from pacea (same year as SST). So for 2021 returns we use 2019, so for
2025 we need 2023, which we do have.

```{r zooplankton}
zooplankton_sog

zoo <- select(zooplankton_sog,
              year,
              total_biomass) %>%
  rename(zoo_total_biomass = total_biomass) %>%
  mutate(return_year = year + 2)
zoo
tail(zoo)

input_age4 <- left_join(input_age4,
                        select(zoo,
                               -"year"))

input_age4
input_age4 %>% tail()
```

### Bifurcation index the year of outmigration

Bifurcation index, year of outmigration, same year as SST (so same as zooplankton).
So, again, for 2021 returns we use 2019, so for 2025 we need 2023, which we do have.

```{r bi}
bi
bi %>% tail()

bi_input <- select(bi,
                   year,
                   anomaly) %>%
  rename(bi_anomaly = anomaly) %>%
  mutate(return_year = year + 2)
bi_input
tail(bi_input)

input_age4 <- left_join(input_age4,
                        select(bi_input,
                               -"year"))

input_age4
input_age4 %>% tail()
```



## Quick EDM, no covariates (text of later sections based on old inputs, needs updating)

Do a quick pbsEDM as proof of concept and to see what we get. Then go back to
previous section to carry on.

From `analyse_simple_time_series` vignette.

Try no covariates, iterate over $E$:

```{r, edm2}
res_univariate <- pbsEDM_Evec(input_age4$age4)
plot_pbsEDM_Evec(res_univariate,
                 portrait = FALSE)

plot_rho_Evec(res_univariate)
```
Does not have the three-armed structure like our simulated model did in our paper.

Those results suggest $E=5$ when using no covariates, and the prediction for 2025 would
be the last of these (I think):
```{r pred1}
res_univariate[[4]]$results

res_univariate[[4]]$N_forecast
res_univariate[[4]]$N_forecast[prediction_year_index]
```

Though they the observed and forecast $N$ look quite different:
```{r obsN}
plot(res_univariate[[4]]$N_observed,
     res_univariate[[4]]$N_forecast)
```

and indeed, `N_rho$ is only `r round(res_univariate[[4]]$results$N_rho, 2)` as seen above.


## EDM with covariates

Now try some covariates, need to understand what is going on here. Lots of
options though. See multiview embedding also.

```{r edm1}
res <- pbsEDM(input_age4,
              lags = list(age4 = c(0, 5),
                          at_sea_abundance = 0,
                          pdo_winter_mean = 0),
              first_difference = TRUE,
              centre_and_scale = TRUE)

plot(res, portrait = FALSE)

```

## Multiview embedding

From `mve_understanding` sort-of-vignette:
```{r mve}
lags_for_mve <- list(age4 = 1:5,   # 0 gives an error, whih makes sense as the response
                     at_sea_abundance = 0,
                     pdo_winter_mean = 0)
mve_full <- multiview_embedding(data = input_age4,
                                response = "age4",
                                lags = lags_for_mve)

# These look to be useful:

mve_full$top_subsets_for_rho_index
mve_full$rho_each_top_subset
mve_full$lags_of_top_subsets

mve_full$response_predicted_from_each_top_subset %>% tail()  # Note that row 74,
                                        # prediction_year_index, has two the
                                        # same (for age4=1:2 in lags).

mve_full$rho_prediction_from_mve

mve_full$response_predicted_from_mve

mve_full$response_predicted_from_mve[prediction_year_index]  # The year of interest

```

Last one has NA from just one prediction. It's this:
`
[[9]]$at_sea_abundance
[1] 0

[[9]]$pdo_winter_mean
[1] 0
`
so excluding any age 4. Should still be able to give a prediction though.

Could do this, but think it's meant to be weighted. Have to dig into the code:
```{r mean}
mean(mve_full$response_predicted_from_each_top_subset[prediction_year_index,],
     na.rm = TRUE)
```
Plus there are lots of NA's in earlier predictions also, so need to figure that out.

Look into how it picks the top embeddings.
